_ = require('lodash')
_.mixin({
	capitalize: function(string) {
		return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	}
});

export ometa OData2AbstractSQL {

	Process :method :body =
		:path
		end
		(	?_.isEmpty(path)
			-> ['$serviceroot']
		|	?(path.resource == '$metadata')
			-> ['$metadata']
		|	PathSegment(method, body, path):queryParts
			{queryParts.query}:query
			(	?queryParts.select.length
				{query.push(['Select', queryParts.select])}
			)?
			{queryParts.where}:where
			{	_.each(queryParts.froms, function(tableName) {
					query.push(['From', tableName]);
				})
			}
			(	?where.length
				(	?(where.length > 1)
					-> query.push(['Where', ['And'].concat(where)])
				|	-> query.push(['Where'].concat(where))
				)
			)?
			(	?(method == 'GET')
				-> ['SelectQuery'].concat(query)
			|	?(method == 'PUT' || method == 'PATCH')
				-> ['UpsertQuery'].concat(query)
			|	?(method == 'POST')
				-> ['InsertQuery'].concat(query)
			|	?(method == 'DELETE')
				-> ['DeleteQuery'].concat(query)
			)
		)
	,
	PathSegment :method :body :path =
		?path.resource
		Resource(path.resource):resource
		{this.defaultResource = path.resource}
		{[]}:query
		{[]}:select
		{[resource.tableName]}:froms
		{[]}:where
		(	?path.property
			PathSegment(method, body, path.property):childQuery
			{query.concat(childQuery.query)}:query
			{select.concat(childQuery.select)}:select
			{froms.concat(childQuery.froms)}:froms
			{where.concat(childQuery.where)}:where

			(	?path.property.resource
			|	{throw 'PathSegment has a property without a resource?'}
			)
			Resource(path.property.resource):propertyResource
			NavigateResources(resource, propertyResource):navigationWhere
			-> where.push(navigationWhere)
		|	?path.link
			(	?path.link.resource
			|	{throw 'PathSegment has a link without a resource?'}
			)
			Resource(path.link.resource):linkResource
			(	FieldContainedIn(linkResource.tableName, resource.fields)
				ReferencedField(resource.resourceName, linkResource.resourceName)
			|	FieldContainedIn(resource.tableName, linkResource.fields)
				ReferencedField(linkResource.resourceName, resource.resourceName)
			|	{throw 'Cannot navigate links'}
			):referencedField
			(	?path.link.key
				-> where.push(['Equals', referencedField, ['Number', path.link.key]])
			)?
			-> select.push(referencedField)
		|	?(method == 'PUT' || method == 'POST' || method == 'PATCH')
			ResourceMapping(resource.modelName):resourceMapping
			Fields(method, body, resource.modelName, _.pairs(resourceMapping)):fields
			-> query.push(['Fields', fields])
		|	?path.options
			?path.options.$select
			AddExtraFroms(path.options.$select.properties, froms, where, resource)
			Properties(path.options.$select.properties):fields
			{select.concat(fields)}:select
		|	(	?path.options
				?path.options.$expand
				Expands(resource, select, froms, where, path.options.$expand.properties)
			)?
			-> select.push([resource.tableName, '*'])
		)

		(	?(!path.options)
		|	(	?(!path.options.$filter)
			|	AddExtraFroms(path.options.$filter, froms, where, resource)
				Boolean(path.options.$filter):filter
				-> where.push(filter)
			)
			(	?(!path.options.$orderby)
			|	AddExtraFroms(path.options.$orderby.properties, froms, where, resource)
				OrderBy(path.options.$orderby.properties):orderby
				-> query.push(['OrderBy'].concat(orderby))
			)
			(	?(!path.options.$top)
			|	Number(path.options.$top):limit
				-> query.push(['Limit', limit])
			)
			(	?(!path.options.$skip)
			|	Number(path.options.$skip):offset
				-> query.push(['Offset', offset])
			)
		)

		(	?path.key
			-> where.push(['Equals', ['ReferencedField', resource.tableName, resource.idField], ['Number', path.key]])
		)?

		-> { query: query, select: select, froms: froms, where: where }
	,

	OrderBy =
		[	(	:ordering
				Property(ordering):field
				-> [ordering.order.toUpperCase(), field]
			)+:orderby
		]
		-> orderby
	,

	Fields :method :body :resourceName =
		[	(	[	'_name'
					anything
				]
				-> null
			|	[	:fieldName
					[	:mappedTableName
						:mappedFieldName
					]
				]
				(	?(method == 'PATCH' && (!body || (!body[fieldName] && !body[resourceName + "." + fieldName])))
					-> null
				|	-> [mappedFieldName, ['Bind', resourceName, fieldName]]
				)
			)*:fields
		]
		-> _.compact(fields)
	,

	Resource :resourceName =
			{this.clientModel.resources[resourceName]}:resource
			?resource
			(	?resource.tableName
			|	ResourceMapping(resourceName):resourceMapping
				{resource.tableName = resourceMapping._name}
			)
			-> resource
		|	{throw 'Unknown resource: ' + resourceName}
	,

	FieldContainedIn :fieldName =
		{false}:contained
		[	(	:field
				(	?(field.fieldName == fieldName)
					{true}:contained
				)?
			)*
		]
		?contained
	,

	ResourceMapping :resourceName =
			?this.clientModel.resourceToSQLMappings[resourceName]
			-> this.clientModel.resourceToSQLMappings[resourceName]
		|	{throw 'Unknown resource: ' + resourceName}
	,

	ReferencedField :resourceTable :resourceField =
		ResourceMapping(resourceTable):mapping
		(	?mapping[resourceField]
			-> ['ReferencedField'].concat(mapping[resourceField])
		|	{console.log(mapping)}{throw 'Unknown mapping: ' + resourceTable + ' : ' + resourceField}
		)
	,

	Boolean =
			[	(	'eq'
					-> 'Equals'
				|	'ne'
					-> 'NotEquals'
				|	'gt'
					-> 'GreaterThan'
				|	'ge'
					-> 'GreaterThanOrEqual'
				|	'lt'
					-> 'LessThan'
				|	'le'
					-> 'LessThanOrEqual'
				):operation
				Operand:op1
				Operand:op2
			|	(	'and'
					-> 'And'
				|	'or'
					-> 'Or'
				):operation
				Boolean:op1
				Boolean:op2
			]
			-> [operation, op1, op2]
		|	[	'not'
				Boolean:bool
			]
			-> ['Not', bool]
		|	Property
		|	BooleanFunction
	,

	BooleanFunction =
			Function('substringof')
		|	Function('startswith')
		|	Function('endswith')
	,

	NumberFunction =
			Function('length')
		|	Function('indexof')
		|	Function('round')
		|	Function('floor')
		|	Function('ceiling')
	,

	TextFunction =
			Function('replace')
		|	Function('substring')
		|	Function('tolower')
		|	Function('toupper')
		|	Function('trim')
		|	Function('concat')
	,

	Function :name =
		[	'call'
			:properties
			?(properties.method == name)
			Arguments(properties.args):args
		]
		-> [_.capitalize(name)].concat(args)
	,

	Arguments =
		[	Operand*:args
		]
		-> args
	,

	Operand =
			Boolean
		|	Number
		|	Text
		|	Math
	,

	Math =
		[	(	'add'
				-> 'Add'
			|	'sub'
				-> 'Subtract'
			|	'mul'
				-> 'Multiply'
			|	'div'
				-> 'Divide'
			):operation
			Operand:op1
			Operand:op2
		]
		-> [operation, op1, op2]
	,

	Properties =
		[	Property*:props
		]
		-> props
	,

	Property =
		:prop
		?prop.name
		(	?prop.property
			(	?prop.property.name
				(	?prop.property.property
					Property(prop.property)
				|	ReferencedField(prop.name, prop.property.name)
				)
			|	{console.error(prop)}
				{throw 'Subproperty without a name'}
			)
		|	ReferencedField(this.defaultResource, prop.name)
		)
	,

	Number =
			number:num
			-> ['Number', num]
		|	NumberFunction
	,

	Text =
			string:text
			-> ['Text', text]
		|	TextFunction
	,

	Expands :resource :select :froms :where =
		[	(	:expand
				(	?(!expand.property)
					Resource(expand.name):extraResource
					AddNavigation(froms, where, resource, extraResource)
					{select.push([expand.name, '*'])}
				|	Resource(expand.name):extraResource
					AddNavigation(froms, where, resource, extraResource)
					Resource(expand.property.name):extraResource2
					AddNavigation(froms, where, extraResource, extraResource2)
					{select.push([expand.property.name, '*'])}
				)
			)*
		]
	,

	NavigateResources :resource1 :resource2 =
		(	FieldContainedIn(resource1.tableName, resource2.fields)
			ReferencedField(resource2.resourceName, resource1.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource1.tableName, resource1.idField],
				fkField
			]
		|	FieldContainedIn(resource2.tableName, resource1.fields)
			ReferencedField(resource1.resourceName, resource2.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource2.tableName, resource2.idField],
				fkField
			]
		|	{throw 'Cannot navigate resources'}
		)
	,

	AddExtraFroms :searchPoint :froms :where :resource =
		ExtraFroms(searchPoint):extraFroms
		{	_.each(extraFroms, function(resourceName) {
				var currentResource = resource;
				if(_.isArray(resourceName)) {
					_.each(resourceName, function(resourceName) {
						var extraResource = this.Resource(resourceName);
						this.AddNavigation(froms, where, currentResource, extraResource);
						currentResource = extraResource;
					}, this);
				}
				else {
					var extraResource = this.Resource(resourceName);
					this.AddNavigation(froms, where, currentResource, extraResource);
				}
			}, this);
		}
	,

	// Returns the resource names.
	ExtraFroms =
		{[]}:froms
		?(_.isArray(this.input.hd))
		[	(	:nextProp
				(	{nextProp}:prop
					?prop.name
					?prop.property
					?prop.property.name
					{prop.property}:nextProp
					-> prop.name
				)+:extraFroms
				(	?(extraFroms.length == 1)
					-> froms.push(extraFroms[0])
				|	-> froms.push(extraFroms)
				)
			|	ExtraFroms:extraFroms
				{froms.concat(extraFroms)}:froms
			|	anything
			)*
		]
		-> froms
	,

	AddNavigation :froms :where :resource :extraResource =
		(	?(!_.contains(froms, extraResource.tableName))
			NavigateResources(resource, extraResource):nagivationWhere
			{froms.push(extraResource.tableName)}
			{where.push(nagivationWhere)}
		)?
}