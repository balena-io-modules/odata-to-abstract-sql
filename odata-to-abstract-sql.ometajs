_ = require('lodash')
_.mixin({
	capitalize: function(string) {
		return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	}
});

var Query = function() {
	_.extend(this, {
		select: [],
		from: [],
		where: [],
		extras: []
	});
};
Query.prototype.merge = function(otherQuery) {
	this.select = this.select.concat(otherQuery.select);
	this.from = this.from.concat(otherQuery.from);
	this.where = this.where.concat(otherQuery.where);
	this.extras = this.extras.concat(otherQuery.extras);
};
Query.prototype.compile = function(queryType) {
	var compiled = [queryType],
		where = this.where;
	if(queryType === 'SelectQuery') {
		compiled.push(['Select', this.select]);
	}
	_.each(this.from, function(tableName) {
		compiled.push(['From', tableName]);
	});
	if(where.length > 0) {
		if(where.length > 1) {
			where = [['And'].concat(where)];
		}
		compiled.push(['Where'].concat(where));
	}
	return compiled.concat(this.extras);
};

export ometa OData2AbstractSQL {

	Process :method :body =
		:path
		end
		(	?_.isEmpty(path)
			-> ['$serviceroot']
		|	?_.contains(['$metadata', '$serviceroot'], path.resource)
			-> [path.resource]
		|	PathSegment(method, body, path):query
			(	?(method == 'GET')
				-> 'SelectQuery'
			|	?(method == 'PUT')
				-> 'UpsertQuery'
			|	?(method == 'PATCH' || method == 'MERGE')
				-> 'UpdateQuery'
			|	?(method == 'POST')
				-> 'InsertQuery'
			|	?(method == 'DELETE')
				-> 'DeleteQuery'
			):queryType
			-> query.compile(queryType)
		)
	,
	PathSegment :method :body :path =
		?path.resource
		Resource(path.resource):resource
		{this.defaultResource = path.resource}
		{new Query()}:query
		{query.from.push(resource.tableName)}

		ReferencedField(resource.resourceName, resource.idField):referencedIdField
		PathKey(path, query, resource, referencedIdField, body)?

		(	?path.options
			?path.options.$expand
			Expands(resource, query, path.options.$expand.properties)
		)?
		(	?path.property
			PathSegment(method, body, path.property):childQuery
			{query.merge(childQuery)}
			(	?path.property.resource
			|	{throw 'PathSegment has a property without a resource?'}
			)
			Resource(path.property.resource):propertyResource
			NavigateResources(resource, propertyResource):navigationWhere
			-> query.where.push(navigationWhere)
		|	?path.link
			(	?path.link.resource
			|	{throw 'PathSegment has a link without a resource?'}
			)
			Resource(path.link.resource):linkResource
			(	FieldContainedIn(linkResource.resourceName, resource)
				ReferencedField(resource.resourceName, linkResource.resourceName):referencedField
				-> [referencedField, linkResource.resourceName]
			|	FieldContainedIn(resource.resourceName, linkResource)
				ReferencedField(linkResource.resourceName, resource.resourceName):referencedField
				-> [referencedField, resource.resourceName]
			|	{throw 'Cannot navigate links'}
			):aliasedField
			PathKey(path.link, query, linkResource, referencedField, body)?
			-> query.select.push(aliasedField)
		|	?(method == 'PUT' || method == 'POST' || method == 'PATCH' || method == 'MERGE')
			ResourceMapping(resource.resourceName):resourceMapping
			BindVars(method, body, resource.resourceName, _.pairs(resourceMapping)):bindVars
			{query.extras.push(['Fields', _.map(bindVars, 0)])}
			{query.extras.push(['Values', _.map(bindVars, 1)])}
		|	?path.options
			?path.options.$select
			AddExtraFroms(path.options.$select.properties, query, resource)
			Properties(path.options.$select.properties):fields
			{	_(fields)
				.reject(function(field) {
					return _.any(query.select, function(existingField) {
						return existingField[existingField.length - 1] == field.name;
					});
				}, this)
				.map(function(field) {
					return this.AliasSelectField(field.resource, field.name);
				}, this)
				.value();
			}:fields
			{query.select = query.select.concat(fields)}
		|	AddSelectFields(resource.resourceName, query.select):select
			{query.select = select}
		)

		(	?(!path.options)
		|	(	?(!path.options.$filter)
			|	?(method == 'POST')
				// Ignore filters in a POST as we currently have no way to handle them..
				// TODO: Use an INSERT INTO SELECT ... to allow filters in an insert?
			|	?(method == 'PATCH' || method == 'MERGE' || method == 'DELETE')
				// For update statements we need to use a WHERE id IN (SELECT...) style query
				{new Query()}:subQuery
				AddExtraFroms(path.options.$filter, subQuery, resource)
				Boolean(path.options.$filter):filter
				{subQuery.select.push(referencedIdField)}
				{subQuery.from.push(resource.tableName)}
				{subQuery.where.push(filter)}
				-> query.where.push(['In', referencedIdField, subQuery.compile('SelectQuery')])
			|	AddExtraFroms(path.options.$filter, query, resource)
				Boolean(path.options.$filter):filter
				-> query.where.push(filter)
			)
			(	?(!path.options.$orderby)
			|	AddExtraFroms(path.options.$orderby.properties, query, resource)
				OrderBy(path.options.$orderby.properties):orderby
				-> query.extras.push(['OrderBy'].concat(orderby))
			)
			(	?(!path.options.$top)
			|	Number(path.options.$top):limit
				-> query.extras.push(['Limit', limit])
			)
			(	?(!path.options.$skip)
			|	Number(path.options.$skip):offset
				-> query.extras.push(['Offset', offset])
			)
		)

		-> query
	,

	PathKey :path :query :resource :referencedField :body =
		?path.key
		// Add the id field value to the body if it doesn't already exist.
		{resource.modelName + '.' + resource.idField}:qualifiedIDField
		(	?(!body[qualifiedIDField] && !body[resource.idField])
			{body[qualifiedIDField] = path.key}
		)?
		(	Number(path.key)
		|	Text(path.key)
		):key
		-> {query.where.push(['Equals', referencedField, key])}
	,

	OrderBy =
		[	(	:ordering
				ReferencedProperty(ordering):field
				-> [ordering.order.toUpperCase(), field]
			)+:orderby
		]
		-> orderby
	,

	BindVars :method :body :resourceName =
		[	(	[	'_name'
					anything
				]
				-> null
			|	[	:fieldName
					[	:mappedTableName
						:mappedFieldName
					]
				]
				(	?((method === 'PATCH' || method === 'MERGE' || method === 'POST') && (!body || (!body.hasOwnProperty(fieldName) && !body.hasOwnProperty(resourceName + "." + fieldName))))
					-> null
				|	-> [mappedFieldName, ['Bind', resourceName, fieldName]]
				)
			)*:fields
		]
		-> _.compact(fields)
	,

	ResolveResourceAlias :aliasName =
		-> (this.resourceAliases[aliasName] || aliasName)
	,

	Resource :resourceName =
			ResolveResourceAlias(resourceName):resourceName
			{this.clientModel.resources[resourceName]}:resource
			?resource
			(	?resource.tableName
			|	ResourceMapping(resourceName):resourceMapping
				{resource.tableName = resourceMapping._name}
			)
			-> resource
		|	{throw 'Unknown resource: ' + resourceName}
	,

	FieldContainedIn :resourceName :table =
		ResourceMapping(table.resourceName):mapping
		{mapping[resourceName]}:mappedField
		?mappedField
		?(mappedField[0] == table.tableName)
		?_.any(table.fields, {fieldName: mappedField[1]})
	,

	ResourceMapping :resourceName =
			ResolveResourceAlias(resourceName):resourceName
			?this.clientModel.resourceToSQLMappings[resourceName]
			-> this.clientModel.resourceToSQLMappings[resourceName]
		|	{throw 'Unknown resource: ' + resourceName}
	,

	AddSelectFields :resourceName :select =
		ResourceMapping(resourceName):resourceMapping
		-> select.concat(
			_(resourceMapping).keys().reject(function(fieldName) {
				return fieldName === '_name' || _.any(select, function(existingField) {
					return existingField[existingField.length - 1] == fieldName;
				});
			}).map(_.bind(this.AliasSelectField, this, resourceName)).value()
		),

	AliasSelectField :resourceName :fieldName =
		ReferencedField(resourceName, fieldName):referencedField
		(	?(referencedField[2] === fieldName)
			-> referencedField
		|	-> [referencedField, fieldName]
		)
	,

	ReferencedField :resourceTable :resourceField =
		ResourceMapping(resourceTable):mapping
		(	?mapping[resourceField]
			-> ['ReferencedField'].concat(mapping[resourceField])
		|	{console.error('Unknown mapping: ', mapping, resourceTable, resourceField)}
			{throw 'Unknown mapping: ' + resourceTable + ' : ' + resourceField}
		)
	,

	Boolean =
			[	(	(	'eq'
						-> 'Equals'
					|	'ne'
						-> 'NotEquals'
					|	'gt'
						-> 'GreaterThan'
					|	'ge'
						-> 'GreaterThanOrEqual'
					|	'lt'
						-> 'LessThan'
					|	'le'
						-> 'LessThanOrEqual'
					):operation
					Operand:op1
					Operand:op2
					-> [operation, op1, op2]
				|	(	'and'
						-> 'And'
					|	'or'
						-> 'Or'
					):operation
					Boolean:op1
					Boolean+:op2
					-> [operation, op1].concat(op2)
				):bool
			]
			-> bool
		|	[	'not'
				Boolean:bool
			]
			-> ['Not', bool]
		|	ReferencedProperty
		|	BooleanFunction
	,

	BooleanFunction =
			Function('substringof')
		|	Function('startswith')
		|	Function('endswith')
	,

	NumberFunction =
			AliasedFunction('length', 'CharacterLength')
		|	Function('indexof')
		|	Function('round')
		|	Function('floor')
		|	Function('ceiling')
	,

	TextFunction =
			Function('replace')
		|	Function('substring'):fn
			// First parameter needs to be increased by 1.
			{fn[2][1]++}
			-> fn
		|	Function('tolower')
		|	Function('toupper')
		|	Function('trim')
		|	Function('concat')
	,

	AliasedFunction :odataName :sqlName =
		Function(odataName):fn
		-> [sqlName].concat(fn.slice(1))
	,

	Function :name =
		[	'call'
			:properties
			?(properties.method == name)
			Arguments(properties.args):args
		]
		-> [_.capitalize(name)].concat(args)
	,

	Arguments =
		[	Operand*:args
		]
		-> args
	,

	Operand =
			Boolean
		|	Number
		|	Text
		|	Date
		|	Math
	,

	Math =
		[	(	'add'
				-> 'Add'
			|	'sub'
				-> 'Subtract'
			|	'mul'
				-> 'Multiply'
			|	'div'
				-> 'Divide'
			):operation
			Operand:op1
			Operand:op2
		]
		-> [operation, op1, op2]
	,

	Lambda :resource :lambda =
		{this.resourceAliases}:resourceAliases
		{	this.resourceAliases = _.clone(this.resourceAliases);
			this.resourceAliases[lambda.identifier] = resource.resourceName;
		}
		(	{new Query()}:query
			Resource(this.defaultResource):defaultResource
			AddNavigation(query, defaultResource, resource)
			AddExtraFroms(lambda.expression, query, resource)
			Boolean(lambda.expression):filter
			{query.where.push(filter)}
			{query.compile('SelectQuery')}:query
			(	?(lambda.method == 'any')
				-> ['Exists', query]
			|	?(lambda.method == 'all')
				-> ['Not',
					['Exists',
						// Where not..
						_.map(query, function(queryPart) {
							if(queryPart[0] == 'Where') {
								return [queryPart[0], ['Not', queryPart[1]]];
							}
							return queryPart;
						})
					]
				]
			):result
			// Make sure resourceAliases are always reset at the end.
			{this.resourceAliases = resourceAliases}
		|	{this.resourceAliases = resourceAliases}
			?false
		)
		-> result
	,

	Properties =
		[	Property*:props
		]
		-> props
	,

	ReferencedProperty =
		Property:prop
		(	?_.isArray(prop)
			// It's the result of a lambda
			-> prop
		|	ReferencedField(prop.resource, prop.name)
		)
	,

	Property =
		:prop
		?prop.name
		(	?prop.property
			(	?prop.property.name
				(	?prop.property.property
					Property(prop.property)
				|	-> {resource: prop.name, name: prop.property.name}
				)
			|	{console.error(prop)}
				{throw 'Subproperty without a name'}
			)
		|	?prop.lambda
			Resource(prop.name):resource
			Lambda(resource, prop.lambda)
		|	-> {resource: this.defaultResource, name: prop.name}
		)
	,

	Number =
			number:num
			-> ['Number', num]
		|	NumberFunction
	,

	Text =
			string:text
			-> ['Text', text]
		|	TextFunction
	,

	Date =
		anything:date
		?_.isDate(date)
		-> ['Date', date]
	,

	Expands :resource :query =
		[	(	:expand
				Resource(expand.name):expandResource
				// We need to nest the expand query in order to be able to alias column names to match the OData version.
				{new Query()}:nestedExpandQuery
				(	?expand.property
					Expands(expandResource, nestedExpandQuery, [expand.property])
				)?
				{nestedExpandQuery.select = this.AddSelectFields(expandResource.resourceName, nestedExpandQuery.select)}
				{nestedExpandQuery.from.push(expandResource.tableName)}
				NavigateResources(resource, expandResource):navigationWhere
				{nestedExpandQuery.where.push(navigationWhere)}

				{new Query()}:expandQuery
				{expandQuery.select.push([['AggregateJSON', [expandResource.tableName, '*']], expandResource.resourceName])}
				{expandQuery.from.push([nestedExpandQuery.compile('SelectQuery'), expandResource.tableName])}
				{query.select.push([expandQuery.compile('SelectQuery'), expandResource.resourceName])}
			)+
		]
	,

	NavigateResources :resource1 :resource2 =
		(	FieldContainedIn(resource1.resourceName, resource2)
			ReferencedField(resource2.resourceName, resource1.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource1.tableName, resource1.idField],
				fkField
			]
		|	FieldContainedIn(resource2.resourceName, resource1)
			ReferencedField(resource1.resourceName, resource2.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource2.tableName, resource2.idField],
				fkField
			]
		|	{throw 'Cannot navigate resources ' + resource1.tableName + ' and ' + resource2.tableName}
		)
	,

	AddExtraFroms :searchPoint :query :resource =
		ExtraFroms(searchPoint):extraFroms
		{	_.each(extraFroms, function(resourceName) {
				var currentResource = resource;
				if(_.isArray(resourceName)) {
					_.each(resourceName, function(resourceName) {
						var extraResource = this.Resource(resourceName);
						this.AddNavigation(query, currentResource, extraResource);
						currentResource = extraResource;
					}, this);
				}
				else {
					var extraResource = this.Resource(resourceName);
					this.AddNavigation(query, currentResource, extraResource);
				}
			}, this);
		}
	,

	// Returns the resource names.
	ExtraFroms =
		{[]}:froms
		(	?(_.isArray(this.input.hd))
			[	(	ExtraFroms:extraFroms
					{froms.concat(extraFroms)}:froms
				)*
			]
		|	:nextProp
			(	{nextProp}:prop
				?prop
				?prop.name
				?prop.property
				?prop.property.name
				{prop.property}:nextProp
				ResolveResourceAlias(prop.name)
			)+:extraFroms
			(	?(extraFroms.length == 1)
				-> froms.push(extraFroms[0])
			|	-> froms.push(extraFroms)
			)
		| anything
		)
		-> froms
	,

	AddNavigation :query :resource :extraResource =
		(	?(!_.contains(query.from, extraResource.tableName))
			NavigateResources(resource, extraResource):nagivationWhere
			{query.from.push(extraResource.tableName)}
			{query.where.push(nagivationWhere)}
		)?
}

OData2AbstractSQL.initialize = function() {
	this.resourceAliases = {};
};