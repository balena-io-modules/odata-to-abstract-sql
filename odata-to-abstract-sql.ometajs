_ = require('lodash')

export ometa OData2AbstractSQL {

	Process :method =
		:path
		end
		(	?_.isEmpty(path)
			-> []
		|	?(path.resource == '$metadata')
			-> ['$metadata']
		|	PathSegment(method, path):queryParts
			{queryParts.query}:query
			{queryParts.where}:where
			{	_.each(queryParts.froms, function(tableName) {
					query.push(['From', tableName]);
				})
			}
			(	?where.length
				(	?(where.length > 1)
					-> query.push(['Where', ['And'].concat(where)])
				|	-> query.push(['Where'].concat(where))
				)
			)?
			(	?(method == 'GET')
				-> ['SelectQuery'].concat(query)
			|	?(method == 'PUT')
				-> ['UpsertQuery'].concat(query)
			|	?(method == 'POST')
				-> ['InsertQuery'].concat(query)
			|	?(method == 'DELETE')
				-> ['DeleteQuery'].concat(query)
			)
		)
	,
	PathSegment :method :path =
		?path.resource
		Resource(path.resource):resource
		{[]}:query
		{[resource.tableName]}:froms
		{[]}:where
		(	?path.property
			PathSegment(method, path.property):childQuery
			{query.concat(childQuery.query)}:query
			{froms.concat(childQuery.froms)}:froms
			{where.concat(childQuery.where)}:where

			Resource(path.property.resource):propertyResource
			NavigateResources(resource, propertyResource):navigationWhere
			-> where.push(navigationWhere)
		|	?path.link
			Resource(path.link.resource):linkResource
			(	FieldContainedIn(linkResource.tableName, resource.fields)
				-> ['ReferencedField', resource.tableName, linkResource.tableName]
			|	FieldContainedIn(resource.tableName, linkResource.fields)
				-> ['ReferencedField', linkResource.tableName, resource.tableName]
			|	{throw 'Cannot navigate links'}
			):referencedField
			(	?path.link.key
				-> where.push(['Equals', referencedField, ['Number', path.key]])
			)?
			-> query.push(['Select', [referencedField]])
		|	?(method == 'PUT' || method == 'POST')
			Fields(resource.tableName, resource.fields):fields
			-> query.push(['Fields', fields])
		|	-> query.push(['Select', [[resource.tableName, '*']]])
		)

		(	?(!path.options)
		|	(	?(!path.options.$filter)
			|	ExtraFroms(path.options.$filter):extraFroms
				{	_.each(extraFroms, function(resourceName) {
						var extraResource = this.Resource(resourceName);
						if(!_.contains(froms, extraResource.tableName)) {
							var nagivationWhere = this.NavigateResources(resource, extraResource);
							where.push(nagivationWhere);
							froms.push(extraResource.tableName);
						}
					}, this);
				}
				Boolean(path.options.$filter):filter
				-> where.push(filter)
			)
			(	?(!path.options.$orderby)
			|	OrderBy(path.options.$orderby.properties):orderby
				-> query.push(['OrderBy'].concat(orderby))
			)
		)

		(	?path.key
			-> where.push(['Equals', ['ReferencedField', resource.tableName, resource.idField], ['Number', path.key]])
		)?

		-> { query: query, froms: froms, where: where }
	,

	OrderBy =
		[	(	:ordering
				-> [ordering.order.toUpperCase(), ['Field', ordering.name]]
			)+:orderby
		]
		-> orderby
	,

	Fields :tableName =
		[	(	:field
				-> [field.fieldName,['Bind', tableName, field.fieldName]]
			)*:fields
		]
		-> fields
	,

	Resource :resourceName =
			{this.clientModel.resources[resourceName]}:resource
			?resource
			(	?resource.tableName
			|	ResourceMapping(resourceName):resourceMapping
				{resource.tableName = resourceMapping._name}
			)
			-> resource
		|	{throw 'Unknown resource: ' + resourceName}
	,

	FieldContainedIn :fieldName =
		{false}:contained
		[	(	:field
				(	?(field.fieldName == fieldName)
					{true}:contained
				)?
			)*
		]
		?contained
	,

	ResourceMapping :resourceName =
			?this.clientModel.resourceToSQLMappings[resourceName]
			-> this.clientModel.resourceToSQLMappings[resourceName]
		|	{throw 'Unknown resource: ' + resourceName}
	,

	Boolean =
			[	(	'eq'
					-> 'Equals'
				|	'ne'
					-> 'NotEquals'
				|	'gt'
					-> 'GreaterThan'
				|	'ge'
					-> 'GreaterThanOrEqual'
				|	'lt'
					-> 'LessThan'
				|	'le'
					-> 'LessThanOrEqual'
				):operation
				Operand:op1
				Operand:op2
			|	(	'and'
					-> 'And'
				|	'or'
					-> 'Or'
				):operation
				Boolean:op1
				Boolean:op2
			]
			-> [operation, op1, op2]
		|	[	'not'
				Boolean:bool
			]
			-> ['Not', bool]
		|	Property
	,

	Operand =
			Boolean
		|	Number
		|	Text
		|	Math
	,

	Math =
		[	(	'add'
				-> 'Add'
			|	'sub'
				-> 'Subtract'
			|	'mul'
				-> 'Multiply'
			|	'div'
				-> 'Divide'
			):operation
			Operand:op1
			Operand:op2
		]
		-> [operation, op1, op2]
	,

	Property =
		:prop
		?prop.name
		(	?prop.property
			(	?prop.property.name
				-> ['ReferencedField', prop.name, prop.property.name]
			|	{console.error(prop)}
				{throw 'Subproperty without a name'}
			)
		|	-> ['Field', prop.name]
		)
	,

	Number =
		number:num
		-> ['Number', num]
	,

	Text =
		string:text
		-> ['Text', text]
	,

	NavigateResources :resource1 :resource2 =
			FieldContainedIn(resource1.tableName, resource2.fields)
			-> ['Equals',
				['ReferencedField', resource1.tableName, resource1.idField],
				['ReferencedField', resource2.tableName, resource1.tableName]
			]
		|	FieldContainedIn(resource2.tableName, resource1.fields)
			-> ['Equals',
				['ReferencedField', resource2.tableName, resource2.idField],
				['ReferencedField', resource1.tableName, resource2.tableName]
			]
		|	{throw 'Cannot navigate resources'}
	,

	// Returns the resource names.
	ExtraFroms =
		{[]}:froms
		?(_.isArray(this.input.hd))
		[	(	:prop
				?prop.name
				?prop.property
				?prop.property.name
				-> froms.push(prop.name)
			|	ExtraFroms:extraFroms
				{_.unique(froms.concat(extraFroms))}:froms
			|	anything
			)*
		]
		-> froms
}