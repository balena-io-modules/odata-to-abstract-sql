var _ = require('lodash');
var memoize = require('memoizee');
var randomstring = require('randomstring');

var Query = function() {
	_.extend(this, {
		select: [],
		from: [],
		where: [],
		extras: []
	});
};
Query.prototype.merge = function(otherQuery) {
	this.select = this.select.concat(otherQuery.select);
	this.from = this.from.concat(otherQuery.from);
	this.where = this.where.concat(otherQuery.where);
	this.extras = this.extras.concat(otherQuery.extras);
};
Query.prototype.fromResource = function(resource, args) {
	if (resource.definition) {
		definition = _.cloneDeep(resource.definition);
		rewriteBinds(definition, args.extraBindVars, args.bindVarsLength);
		this.from.push([definition.abstractSqlQuery, resource.tableAlias]);
	} else if (resource.name !== resource.tableAlias) {
		this.from.push([resource.name, resource.tableAlias]);
	} else {
		this.from.push(resource.name);
	}
};
Query.prototype.compile = function(queryType) {
	var compiled = [queryType],
		where = this.where;
	if (queryType === 'SelectQuery') {
		compiled.push(['Select', this.select]);
	}
	_.each(this.from, function(tableName) {
		compiled.push(['From', tableName]);
	});
	if (where.length > 0) {
		if (where.length > 1) {
			where = [['And'].concat(where)];
		}
		compiled.push(['Where'].concat(where));
	}
	return compiled.concat(this.extras);
};

var sqlNameToODataName = memoize(function(sqlName) {
	return sqlName.replace(/-/g, '__').replace(/ /g, '_');
}, { primitive: true });
exports.sqlNameToODataName = sqlNameToODataName;
var odataNameToSqlName = memoize(function(odataName) {
	return odataName.replace(/__/g, '-').replace(/_/g, ' ');
}, { primitive: true });
exports.odataNameToSqlName = odataNameToSqlName;

var incrementBinds = function(inc, abstractSql) {
	if (_.isArray(abstractSql)) {
		if (abstractSql[0] === 'Bind') {
			if (_.isNumber(abstractSql[1])) {
				abstractSql[1] += inc;
			}
		} else {
			_.each(abstractSql, function(abstractSql) {
				incrementBinds(inc, abstractSql);
			});
		}
	}
};
var rewriteBinds = function(definition, existingBinds, inc) {
	inc = inc || 0;
	incrementBinds(existingBinds.length + inc, definition.abstractSqlQuery);
	existingBinds.push.apply(existingBinds, definition.extraBinds);
}
exports.rewriteBinds = rewriteBinds;

export ometa OData2AbstractSQL {

	Process :method :bodyKeys :bindVarsLength =
		:path
		end
		{this.bindVarsLength = bindVarsLength}
		(	?_.isEmpty(path)
			-> ['$serviceroot']
		|	?_.includes(['$metadata', '$serviceroot'], path.resource)
			-> [path.resource]
		|	{this.reset()}
			PathSegment(method, bodyKeys, path):query
			(	?(method == 'PUT')
				// For PUT the initial pass generates the update query,
				// so we run it through the parser a second time to get the insert query,
				// for a full upsert query
				{this.reset()}
				PathSegment('PUT-INSERT', bodyKeys, path):insertQuery
				-> ['UpsertQuery', insertQuery.compile('InsertQuery'), query.compile('UpdateQuery')]
			|	(	?(method == 'GET')
					-> 'SelectQuery'
				|	?(method == 'PATCH' || method == 'MERGE')
					-> 'UpdateQuery'
				|	?(method == 'POST')
					-> 'InsertQuery'
				|	?(method == 'DELETE')
					-> 'DeleteQuery'
				):queryType
				-> query.compile(queryType)
			)
		):tree
		-> { tree: tree, extraBodyVars: this.extraBodyVars, extraBindVars: this.extraBindVars }
	,
	PathSegment :method :bodyKeys :path =
		?path.resource
		Resource(path.resource, this.defaultResource):resource
		{this.defaultResource = resource}
		{new Query()}:query
		{query.fromResource(resource, this)}

		// We can't use the ReferencedField rule as resource.idField is the model name (using spaces),
		// not the resource name (with underscores), meaning that the attempts to map fail for a custom id field with spaces.
		{['ReferencedField', resource.tableAlias, resource.idField]}:referencedIdField
		PathKey(path, query, resource, referencedIdField, bodyKeys)

		(	?(!path.options)
		|	?(!path.options.$expand)
		|	Expands(resource, query, path.options.$expand.properties)
		)
		(	?path.property
			PathSegment(method, bodyKeys, path.property):childQuery
			{query.merge(childQuery)}
			(	?path.property.resource
			|	{throw new Error('PathSegment has a property without a resource?')}
			)
			NavigateResources(resource, path.property.resource):navigation
			-> query.where.push(navigation.where)
		|	?path.link
			(	?path.link.resource
			|	{throw new Error('PathSegment has a link without a resource?')}
			)
			Resource(path.link.resource, resource):linkResource
			(	FieldContainedIn(linkResource.resourceName, resource)
				ReferencedField(resource, linkResource.resourceName):referencedField
				-> [referencedField, linkResource.resourceName]
			|	FieldContainedIn(resource.resourceName, linkResource)
				ReferencedField(linkResource, resource.resourceName):referencedField
				-> [referencedField, resource.resourceName]
			|	{throw new Error('Cannot navigate links')}
			):aliasedField
			PathKey(path.link, query, linkResource, referencedField, bodyKeys)
			-> query.select.push(aliasedField)
		|	?(method == 'PUT' || method == 'PUT-INSERT' || method == 'POST' || method == 'PATCH' || method == 'MERGE')
			ResourceMapping(resource):resourceMapping
			BindVars(method, bodyKeys, resource.resourceName, _.toPairs(resourceMapping)):bindVars
			{query.extras.push(['Fields', _.map(bindVars, 0)])}
			{query.extras.push(['Values', _.map(bindVars, 1)])}
		|	AddCountField(path, query, resource)
		|	AddSelectFields(path, query, resource)
		)

		(	?(!path.options)
		|	(	?(method == 'POST' || method == 'PUT-INSERT')
				(	?path.options.$filter
					InsertFilter(path.options.$filter, resource, bindVars):subQuery
					{_.findIndex(query.extras, {0: 'Values'})}:valuesIndex
					// Replace the values bind var list with our filtered SELECT query.
					-> (query.extras[valuesIndex] = ['Values', subQuery.compile('SelectQuery')])
				)?
			|	?(method == 'PUT' || method == 'PATCH' || method == 'MERGE' || method == 'DELETE')
				// For update statements we need to use a WHERE id IN (SELECT...) style query
				{new Query()}:subQuery
				{
					subQuery.select.push(referencedIdField)
					subQuery.fromResource(resource, this)
				}
				AddQueryOptions(resource, path, subQuery)
				-> query.where.push(['In', referencedIdField, subQuery.compile('SelectQuery')])
			|	AddQueryOptions(resource, path, query)
			)
		)

		-> query
	,

	PathKey :path :query :resource :referencedField :bodyKeys =
		(	?(path.key == null)
		|	// Add the id field value to the body if it doesn't already exist.
			{resource.resourceName + '.' + resource.idField}:qualifiedIDField
			(	?(!_.includes(bodyKeys, qualifiedIDField) && !_.includes(bodyKeys, resource.idField))
				{bodyKeys.push(qualifiedIDField)}
				{this.extraBodyVars[qualifiedIDField] = path.key}
			)?
			(	Bind(path.key)
			|	Number(path.key)
			|	Text(path.key)
			):key
			-> {query.where.push(['Equals', referencedField, key])}
		)
	,

	Bind =
		:bind
		?(bind != null)
		?(bind.bind != null)
		-> ['Bind', bind.bind]
	,

	SelectFilter :filter :query :resource =
		AddExtraFroms(query, resource, filter)
		Boolean(filter):filter
		-> query.where.push(filter)
	,

	InsertFilter :filter :resource :bindVars =
		// For insert statements we need to use an INSERT INTO ... SELECT * FROM (binds) WHERE ... style query
		{new Query()}:query
		AddExtraFroms(query, resource, filter)
		Boolean(filter):where
		{
			query.select = _.map(bindVars, function(bindVar) {
				return ['ReferencedField', resource.tableAlias, bindVar[0]]
			})
			query.from.push([
				[	'SelectQuery',
					[	'Select',
						_.map(resource.fields, function(field) {
							var cast,
								alias = field.fieldName,
								bindVar = _.find(bindVars, { 0: alias }),
								value = bindVar ? bindVar[1] : 'Null';
							return [['Cast', value, field.dataType], alias];
						})
					]
				],
				resource.tableAlias
			])
			query.where.push(where)
		}
		-> query
	,

	OrderBy :orderby :query :resource =
		AddExtraFroms(query, resource, orderby.properties)
		OrderByProperties(orderby.properties):orderby
		-> query.extras.push(['OrderBy'].concat(orderby))
	,

	OrderByProperties =
		[	(	:ordering
				ReferencedProperty(ordering):field
				-> [ordering.order.toUpperCase(), field]
			)+:orderby
		]
		-> orderby
	,

	BindVars :method :bodyKeys :resourceName =
		[	(	[	:fieldName
					[	:mappedTableName
						:mappedFieldName
					]
				]
				(	?(!_.includes(bodyKeys, fieldName) && !_.includes(bodyKeys, resourceName + "." + fieldName))
					// The body doesn't contain a bind var for this field.
					(	?(method === 'PUT')
						-> [mappedFieldName, 'Default']
					|	-> null
					)
				|	-> [mappedFieldName, ['Bind', resourceName, fieldName]]
				)
			)*:fields
		]
		-> _.compact(fields)
	,

	ResolveResourceAlias :aliasName =
		?this.resourceAliases[aliasName]
		-> this.resourceAliases[aliasName]
	,

	Resource :resourceName :parentResource =
			ResolveResourceAlias(resourceName)
		|	(	?parentResource
				ResolveRelationship(parentResource, resourceName):relationshipMapping
				-> this.clientModel.tables[relationshipMapping[1][0]]
			|	{odataNameToSqlName(resourceName)}:sqlName
				Synonym(sqlName):sqlName
				-> this.clientModel.tables[sqlName]
			):resource
			?resource
			{_.clone(resource)}:resource

			(	?parentResource
				(	?(_.includes(resourceName, '__') && !_.includes(resource.name, '-'))
					// If we have a __ in the resource name to navigate then we used a verb for navigation,
					// and no dash in the resulting resource name means we don't have the verb in the alias, so we need to add it
					{odataNameToSqlName(resourceName).split('-')[0]}:verb
					-> (verb + '-' + resource.name)
				|	-> resource.name
				):resourceAlias
				-> (parentResource.tableAlias + '.' + resourceAlias)
			|	-> resource.name
			):tableAlias
			{resource.tableAlias = this.checkAlias(tableAlias)}
			-> resource
		|	{throw new Error('Unknown resource: ' + resourceName)}
	,

	FieldContainedIn :fieldName :resource =
		ResolveRelationship(resource, fieldName)
	,

	ResourceMapping :resource =
		(	?resource.tableAlias
			-> resource.tableAlias
		|	-> resource.name
		):tableAlias
		-> _(resource.fields).map(function(field) {
			return [ tableAlias, field.fieldName ]
		}).keyBy(function(mapping) {
			return sqlNameToODataName(mapping[1])
		}).value()
	,
	ResolveRelationship :resource :relationship =
		(	?_.isObject(resource)
			-> resource.resourceName
		|	?this.resourceAliases[resourceName]
			-> this.resourceAliases[resourceName].resourceName
		|	-> resource
		):resourceName
		Synonym(resourceName):resourceName
		{this.clientModel.relationships[resourceName]}:resourceRelations
		?resourceRelations
		{	_(relationship)
			.split('__')
			.map(odataNameToSqlName)
			.flatMap(function(sqlName) {
				return $elf.Synonym(sqlName).split('-')
			}).join('.')
		}:relationshipPath
		{_.get(resourceRelations, relationshipPath)}:relationshipMapping
		?relationshipMapping
		?relationshipMapping.$
		-> relationshipMapping.$
	,

	AddCountField :path :query :resource =
		?path.count
		-> (query.select.push([['Count', '*'], '$count']))
	,

	AddSelectFields :path :query :resource =
		(	?path.options
			?path.options.$select
			AddExtraFroms(query, resource, path.options.$select.properties)
			Properties(path.options.$select.properties):fields
			-> _(fields).reject(function(field) {
					return _.some(query.select, function(existingField) {
						return _.last(existingField) == field.name;
					});
				})
				.map(function(field) {
					return $elf.AliasSelectField(field.resource, field.name);
				})
				.value()
		|	ResourceMapping(resource):resourceMapping
			-> _(resourceMapping).keys().reject(function(fieldName) {
				return _.some(query.select, function(existingField) {
					return _.last(existingField) == fieldName;
				});
			}).map(_.bind(this.AliasSelectField, this, resource)).value()
		):fields
		-> (query.select = query.select.concat(fields))
	,

	AliasSelectField :resource :fieldName =
		ReferencedField(resource, fieldName):referencedField
		(	?(referencedField[2] === fieldName)
			-> referencedField
		|	-> [referencedField, fieldName]
		)
	,

	ReferencedField :resource :resourceField =
		ResourceMapping(resource):mapping
		(	?mapping[resourceField]
			-> ['ReferencedField'].concat(mapping[resourceField])
		|	ResolveRelationship(resource, resourceField):relationshipMapping
			(	?resource.tableAlias
				-> resource.tableAlias
			|	-> resource.name
			):tableAlias
			-> ['ReferencedField', tableAlias, relationshipMapping[0]]
		|	{console.error('Unknown mapping: ', mapping, resource.resourceName, resourceField)}
			{throw new Error('Unknown mapping: ' + resource.resourceName + ' : ' + resourceField)}
		)
	,

	Boolean =
			True
		|	False
		|	[	(	(	'eq'
						-> 'Equals'
					|	'ne'
						-> 'NotEquals'
					|	'gt'
						-> 'GreaterThan'
					|	'ge'
						-> 'GreaterThanOrEqual'
					|	'lt'
						-> 'LessThan'
					|	'le'
						-> 'LessThanOrEqual'
					):operation
					Operand:op1
					Operand:op2
					-> [operation, op1, op2]
				|	(	'and'
						-> 'And'
					|	'or'
						-> 'Or'
					):operation
					Boolean:op1
					Boolean+:op2
					-> [operation, op1].concat(op2)
				|	'not'
					Boolean:bool
					-> ['Not', bool]
				|	'in'
					Operand:op1
					[	Operand*:rest
					]
					-> ['In', op1].concat(rest)
				):bool
			]
			-> bool
		|	ReferencedProperty
		|	BooleanFunction
	,

	True =
		true
		-> ['Boolean', true]
	,

	False =
		false
		-> ['Boolean', false]
	,

	BooleanFunction =
			Function('contains')
		|	Function('endswith')
		|	Function('startswith')
		|	Function('isof')
		|	Function('substringof')
	,

	NumberFunction =
			AliasedFunction('length', 'CharacterLength')
		|	Function('indexof')
		|	Function('year')
		|	Function('month')
		|	Function('day')
		|	Function('day')
		|	Function('hour')
		|	Function('minute')
		|	Function('second')
		|	Function('fractionalseconds')
		|	Function('totaloffsetminutes')
		|	Function('totalseconds')
		|	Function('round')
		|	Function('floor')
		|	Function('ceiling')
	,

	TextFunction =
			Function('substring'):fn
			// First parameter needs to be increased by 1.
			{fn[2] = ['Add', fn[2], ['Number', 1]]}
			-> fn
		|	Function('tolower')
		|	Function('toupper')
		|	Function('trim')
		|	Function('concat')
		|	AliasedFunction('date', 'ToDate')
		|	AliasedFunction('time', 'ToTime')
		|	Function('replace')
	,

	DateFunction =
			Function('now')
		|	Function('maxdatetime')
		|	Function('mindatetime')
	,

	AliasedFunction :odataName :sqlName =
		Function(odataName):fn
		-> [sqlName].concat(fn.slice(1))
	,

	Function :name =
		[	'call'
			:properties
			?(properties.method == name)
			Arguments(properties.args):args
		]
		-> [_.capitalize(name)].concat(args)
	,

	Arguments =
		[	Operand*:args
		]
		-> args
	,

	Operand =
			Bind
		|	Null
		|	Boolean
		|	Number
		|	Text
		|	Date
		|	Duration
		|	Math
	,

	Math =
		[	(	'add'
				-> 'Add'
			|	'sub'
				-> 'Subtract'
			|	'mul'
				-> 'Multiply'
			|	'div'
				-> 'Divide'
			):operation
			Operand:op1
			Operand:op2
		]
		-> [operation, op1, op2]
	,

	Lambda :resourceName :lambda =
		{this.resourceAliases}:resourceAliases
		{this.defaultResource}:defaultResource
		(	{new Query()}:query
			AddNavigation(query, this.defaultResource, resourceName):resource
			{	this.resourceAliases = _.clone(this.resourceAliases);
				this.resourceAliases[lambda.identifier] = resource;
			}
			{this.defaultResource = resource}
			AddExtraFroms(query, resource, lambda.expression)
			Boolean(lambda.expression):filter
			(	?(lambda.method == 'any')
				{query.where.push(filter)}
				-> ['Exists', query.compile('SelectQuery')]
			|	?(lambda.method == 'all')
				// We use `NOT EXISTS NOT ($filter)` to implement all, but we want to leave existing where components intact, as they are for joins
				{query.where.push([ 'Not', filter ])}
				-> ['Not',
					['Exists', query.compile('SelectQuery')]
				]
			):result
			// Make sure resourceAliases/defaultResource are always reset at the end.
			{this.resourceAliases = resourceAliases}
			{this.defaultResource = defaultResource}
		|	{this.resourceAliases = resourceAliases}
			{this.defaultResource = defaultResource}
			?false
		)
		-> result
	,

	Properties =
		[	Property*:props
		]
		-> props
	,

	ReferencedProperty =
		Property:prop
		(	?_.isArray(prop)
			// It's the result of a lambda
			-> prop
		|	ReferencedField(prop.resource, prop.name)
		)
	,

	Property =
		:prop
		?prop.name
		(	?prop.property
			{this.defaultResource}:defaultResource
			(	{	try {
						return $elf.Resource(prop.name, this.defaultResource);
					} catch (e) {}
				}:propResource
				?propResource
				{this.defaultResource = propResource}
				Property(prop.property):result
				{this.defaultResource = defaultResource}
				-> result
			|	{this.defaultResource = defaultResource}
				Property(prop.property)
			)
		|	?(!prop.property)
			?prop.lambda
			Lambda(prop.name, prop.lambda)
		|	?(!prop.property)
			?(!prop.lambda)
			-> {resource: this.defaultResource, name: prop.name}
		)
	,

	Number =
			number:num
			-> ['Number', num]
		|	NumberFunction
	,

	Null =
		anything:x
		?(x === null)
		-> 'Null'
	,

	Text =
			string:text
			-> ['Text', text]
		|	TextFunction
	,

	Date =
			anything:date
			?_.isDate(date)
			-> ['Date', date]
		|	DateFunction
	,

	Duration =
		anything:duration
		?_.isObject(duration)
		{	_(duration)
			.pick('negative', 'day', 'hour', 'minute', 'second')
			.omitBy(_.isNil)
			.value()
		}:duration
		?(!_(duration).omit('negative').isEmpty())
		-> ['Duration', duration]
	,

	Expands :resource :query =
		{this.defaultResource}:defaultResource
		[	(	:expand
				NavigateResources(resource, expand.name):navigation
				{navigation.resource}:expandResource
				{this.defaultResource = expandResource}
				// We need to nest the expand query in order to be able to alias column names to match the OData version.
				{new Query()}:nestedExpandQuery
				(	?(!expand.property)
				|	Expands(expandResource, nestedExpandQuery, [expand.property])
				)
				(	?(!expand.options)
				|	(	?(!expand.options.$expand)
					|	Expands(expandResource, nestedExpandQuery, expand.options.$expand.properties)
					)
				)
				{nestedExpandQuery.fromResource(expandResource, this)}
				(	AddCountField(expand, nestedExpandQuery, expandResource)
				|	AddSelectFields(expand, nestedExpandQuery, expandResource)
				)
				(	?(!expand.options)
				|	AddQueryOptions(expandResource, expand, nestedExpandQuery)
				)

				{this.defaultResource = defaultResource}

				{nestedExpandQuery.where.push(navigation.where)}

				{new Query()}:expandQuery
				{expandQuery.select.push([['AggregateJSON', [expandResource.tableAlias, '*']], expand.name])}
				{expandQuery.from.push([nestedExpandQuery.compile('SelectQuery'), expandResource.tableAlias])}
				{query.select.push([expandQuery.compile('SelectQuery'), expand.name])}
			)+
		]
	,

	AddQueryOptions :resource :path :query =
		(	?(!path.options.$filter)
		|	SelectFilter(path.options.$filter, query, resource)
		)
		(	// When querying /$count, $orderby/$top/$skip must be ignored
			?path.count
		|	(	?(!path.options.$orderby)
			|	OrderBy(path.options.$orderby, query, resource)
			)
			(	?(!path.options.$top)
			|	Number(path.options.$top):limit
				-> query.extras.push(['Limit', limit])
			)
			(	?(!path.options.$skip)
			|	Number(path.options.$skip):offset
				-> query.extras.push(['Offset', offset])
			)
		)
	,

	NavigateResources :resource :navigation =
			ResolveRelationship(resource, navigation):relationshipMapping
			Resource(navigation, resource):linkedResource
			(	?resource.tableAlias
				-> resource.tableAlias
			|	-> resource.name
			):tableAlias
			(	?linkedResource.tableAlias
				-> linkedResource.tableAlias
			|	-> linkedResource.name
			):linkedTableAlias
			-> {
				resource: linkedResource,
				where: ['Equals',
					['ReferencedField', tableAlias, relationshipMapping[0]],
					['ReferencedField', linkedTableAlias, relationshipMapping[1][1]]
				]
			}
		|	{throw new Error('Cannot navigate resources ' + resource.resourceName + ' and ' + navigation)}
	,

	AddExtraFroms :query :parentResource =
		(	?(_.isArray(this.input.hd))
			[	(	AddExtraFroms(query, parentResource)
				)*
			]
		|	:nextProp
			(	{nextProp}:prop
				?prop
				?prop.name
				?prop.property
				?prop.property.name
				{prop.property}:nextProp
				(	ResolveResourceAlias(prop.name)
				|	AddNavigation(query, parentResource, prop.name)
				):parentResource
			)+
		| anything
		)
	,

	AddNavigation :query :resource :extraResource =
		(	NavigateResources(resource, extraResource):navigation
			?(!_.some(query.from, function(from) {
				return from === navigation.resource.tableAlias ||
					(_.isArray(from) && from[1] === navigation.resource.tableAlias);
			}))
			{query.fromResource(navigation.resource, this)}
			{query.where.push(navigation.where)}
			-> navigation.resource
		)?
}

OData2AbstractSQL.initialize = function() {
	this.reset();
};

OData2AbstractSQL.reset = function() {
	this.resourceAliases = {};
	this.defaultResource = null;
	this.extraBodyVars = {};
	this.extraBindVars = [];
};

OData2AbstractSQL.Synonym = function(sqlName) {
	var $elf = this;
	return _(sqlName).split('-').map(function(namePart) {
		var synonym = $elf.clientModel.synonyms[namePart];
		if (synonym) {
			return synonym;
		}
		return namePart;
	}).join('-');
};

OData2AbstractSQL.checkAlias = _.identity;

var generateShortAliases = function(clientModel) {
	var shortAliases = {};
	var addAliases = function(origAliasParts) {
		var trie = {};
		var buildTrie = function(aliasPart) {
			var node = trie;
			_.each(aliasPart, function(c, i) {
				if (node.$suffix) {
					node[node.$suffix[0]] = {
						$suffix: node.$suffix.slice(1)
					};
					delete node.$suffix;
				}
				if (node[c]) {
					node = node[c];
				}
				else {
					node[c] = {
						$suffix: aliasPart.slice(i + 1)
					};
					return false;
				}
			});
		};
		var traverseNodes = function(str, node) {
			_.each(node, function(value, key) {
				if (key === '$suffix') {
					var lowerCaseAliasPart = str + value;
					var origAliasPart = _.find(origAliasParts, function(aliasPart) {
						return aliasPart.toLowerCase() === lowerCaseAliasPart;
					});
					shortAliases[origAliasPart] = origAliasPart.slice(0, str.length);
				} else {
					traverseNodes(str + key, value, origAliasParts);
				}
			});
		};

		_(origAliasParts)
		.invokeMap('toLowerCase')
		.sort()
		.each(buildTrie);

		// Find the shortest unique alias for each term, using the trie.
		traverseNodes('', trie, origAliasParts);
	}


	var getRelationships = function(relationships) {
		if (_.isArray(relationships)) {
			return [];
		} else {
			return _(relationships).keys().reject(function(key) {
				return key === '$';
			}).concat(
				_.flatMap(relationships, getRelationships)
			).uniq().value();
		}
	}
	var aliasParts = getRelationships(clientModel.relationships).concat(_.keys(clientModel.synonyms));



	// Add the first level of aliases, of names split by `-` and ` `, for short aliases on a word by word basis
	var origAliasParts = _(aliasParts).flatMap(function(aliasPart) {
			return aliasPart.split(/-| /);
		})
		.uniq().value();
	addAliases(origAliasParts);

	// Add the second level of aliases, of names that include a ` `, split by `-`, for short aliases on a verb/term basis
	trie = {};
	origAliasParts = _(aliasParts).flatMap(function(aliasPart) {
		return aliasPart.split('-');
	})
	.filter(function(aliasPart) {
		return _.includes(aliasPart, ' ');
	})
	.map(function(aliasPart) {
		return _(aliasPart)
			.split(' ')
			.map(function(part) {
				return shortAliases[part];
			})
			.join(' ');
	})
	.uniq().value();

	addAliases(origAliasParts);

	// Add the third level of aliases, of names that include a `-`, for short aliases on a fact type basis
	trie = {};
	origAliasParts = _(aliasParts)
	.filter(function(aliasPart) {
		return _.includes(aliasPart, '-');
	})
	.map(function(aliasPart) {
		return _(aliasPart)
			.split('-')
			.map(function(part) {
				return shortAliases[part];
			})
			.join('-');
	})
	.uniq().value();

	addAliases(origAliasParts);

	return shortAliases;
};

OData2AbstractSQL.setClientModel = function(clientModel) {
	this.clientModel = clientModel;

	var MAX_ALIAS_LENGTH = 64;
	var RANDOM_ALIAS_LENGTH = 12;
	var shortAliases = generateShortAliases(clientModel);
	this.checkAlias = memoize(function(alias) {
		var aliasLength = alias.length;
		if (aliasLength < MAX_ALIAS_LENGTH) {
			return alias;
		}
		alias = _(alias).split('.').map(function(part) {
			if (aliasLength < MAX_ALIAS_LENGTH) {
				return part;
			}
			aliasLength -= part.length;
			var shortAlias = _(part).split('-').map(function(part) {
				var part = _(part).split(' ').map(function(part) {
					var shortPart = shortAliases[part];
					if (shortPart) {
						return shortPart;
					}
					return part;
				}).join(' ');
				shortPart = shortAliases[part];
				if (shortPart) {
					return shortPart;
				}
				return part;
			}).join('-');
			aliasLength += shortAlias.length;
			return shortAlias;
		}).join('.');

		if (aliasLength < MAX_ALIAS_LENGTH) {
			return alias;
		}

		var randStr = randomstring.generate(RANDOM_ALIAS_LENGTH) + '$';
		return randStr + alias.slice(randStr.length + alias.length - MAX_ALIAS_LENGTH);
	});
};
