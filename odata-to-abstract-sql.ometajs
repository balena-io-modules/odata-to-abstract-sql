_ = require('lodash');

var Query = function() {
	_.extend(this, {
		select: [],
		from: [],
		where: [],
		extras: []
	});
};
Query.prototype.merge = function(otherQuery) {
	this.select = this.select.concat(otherQuery.select);
	this.from = this.from.concat(otherQuery.from);
	this.where = this.where.concat(otherQuery.where);
	this.extras = this.extras.concat(otherQuery.extras);
};
Query.prototype.fromResource = function(resource) {
	if(resource.tableName !== resource.tableAlias) {
		this.from.push([resource.tableName, resource.tableAlias]);
	}
	else {
		this.from.push(resource.tableName);
	}
};
Query.prototype.compile = function(queryType) {
	var compiled = [queryType],
		where = this.where;
	if(queryType === 'SelectQuery') {
		compiled.push(['Select', this.select]);
	}
	_.each(this.from, function(tableName) {
		compiled.push(['From', tableName]);
	});
	if(where.length > 0) {
		if(where.length > 1) {
			where = [['And'].concat(where)];
		}
		compiled.push(['Where'].concat(where));
	}
	return compiled.concat(this.extras);
};

export ometa OData2AbstractSQL {

	Process :method :body =
		:path
		end
		(	?_.isEmpty(path)
			-> ['$serviceroot']
		|	?_.includes(['$metadata', '$serviceroot'], path.resource)
			-> [path.resource]
		|	{this.reset()}
			PathSegment(method, body, path):query
			(	?(method == 'PUT')
				// For PUT the initial pass generates the update query,
				// so we run it through the parser a second time to get the insert query,
				// for a full upsert query
				{this.reset()}
				PathSegment('PUT-INSERT', body, path):insertQuery
				-> ['UpsertQuery', insertQuery.compile('InsertQuery'), query.compile('UpdateQuery')]
			|	(	?(method == 'GET')
					-> 'SelectQuery'
				|	?(method == 'PATCH' || method == 'MERGE')
					-> 'UpdateQuery'
				|	?(method == 'POST')
					-> 'InsertQuery'
				|	?(method == 'DELETE')
					-> 'DeleteQuery'
				):queryType
				-> query.compile(queryType)
			)
		)
	,
	PathSegment :method :body :path =
		?path.resource
		Resource(path.resource, this.defaultResource):resource
		{this.defaultResource = resource}
		{new Query()}:query
		{query.fromResource(resource)}

		// We can't use the ReferencedField rule as resource.idField is the model name (using spaces),
		// not the resource name (with underscores), meaning that the attempts to map fail for a custom id field with spaces.
		{['ReferencedField', resource.tableAlias, resource.idField]}:referencedIdField
		PathKey(path, query, resource, referencedIdField, body)?

		(	?(!path.options)
		|	?(!path.options.$expand)
		|	Expands(resource, query, path.options.$expand.properties)
		)
		(	?path.property
			PathSegment(method, body, path.property):childQuery
			{query.merge(childQuery)}
			(	?path.property.resource
			|	{throw new Error('PathSegment has a property without a resource?')}
			)
			Resource(path.property.resource, resource):propertyResource
			NavigateResources(resource, propertyResource):navigationWhere
			-> query.where.push(navigationWhere)
		|	?path.link
			(	?path.link.resource
			|	{throw new Error('PathSegment has a link without a resource?')}
			)
			Resource(path.link.resource, resource):linkResource
			(	FieldContainedIn(linkResource.resourceName, resource)
				ReferencedField(resource, linkResource.resourceName):referencedField
				-> [referencedField, linkResource.resourceName]
			|	FieldContainedIn(resource.resourceName, linkResource)
				ReferencedField(linkResource, resource.resourceName):referencedField
				-> [referencedField, resource.resourceName]
			|	{throw new Error('Cannot navigate links')}
			):aliasedField
			PathKey(path.link, query, linkResource, referencedField, body)?
			-> query.select.push(aliasedField)
		|	?(method == 'PUT' || method == 'PUT-INSERT' || method == 'POST' || method == 'PATCH' || method == 'MERGE')
			ResourceMapping(resource):resourceMapping
			BindVars(method, body, resource.resourceName, _.toPairs(resourceMapping)):bindVars
			{query.extras.push(['Fields', _.map(bindVars, 0)])}
			{query.extras.push(['Values', _.map(bindVars, 1)])}
		|       AddCountField(path, query, resource)
		|	AddSelectFields(path, query, resource)
		)

		(	?(!path.options)
		|	(	?(!path.options.$filter)
			|	?(method == 'POST' || method == 'PUT-INSERT')
				InsertFilter(path.options.$filter, resource, bindVars):subQuery
				{_.findIndex(query.extras, {0: 'Values'})}:valuesIndex
				// Replace the values bind var list with our filtered SELECT query.
				-> (query.extras[valuesIndex] = ['Values', subQuery.compile('SelectQuery')])
			|	?(method == 'PUT' || method == 'PATCH' || method == 'MERGE' || method == 'DELETE')
				UpdateFilter(path.options.$filter, resource, referencedIdField):subQuery
				-> query.where.push(['In', referencedIdField, subQuery.compile('SelectQuery')])
			|	SelectFilter(path.options.$filter, query, resource)
			)
			(	?(!path.options.$orderby)
			|	OrderBy(path.options.$orderby, query, resource)
			)
			(	?(!path.options.$top)
			|	Number(path.options.$top):limit
				-> query.extras.push(['Limit', limit])
			)
			(	?(!path.options.$skip)
			|	Number(path.options.$skip):offset
				-> query.extras.push(['Offset', offset])
			)
		)

		-> query
	,

	PathKey :path :query :resource :referencedField :body =
		?path.key
		// Add the id field value to the body if it doesn't already exist.
		{resource.resourceName + '.' + resource.idField}:qualifiedIDField
		(	?(!body[qualifiedIDField] && !body[resource.idField])
			{body[qualifiedIDField] = path.key}
		)?
		(	Number(path.key)
		|	Text(path.key)
		):key
		-> {query.where.push(['Equals', referencedField, key])}
	,

	SelectFilter :filter :query :resource =
		AddExtraFroms(filter, query, resource)
		Boolean(filter):filter
		-> query.where.push(filter)
	,

	InsertFilter :filter :resource :bindVars =
		// For insert statements we need to use an INSERT INTO ... SELECT * FROM (binds) WHERE ... style query
		{new Query()}:query
		AddExtraFroms(filter, query, resource)
		Boolean(filter):where
		{
			query.select = _.map(bindVars, function(bindVar) {
				return ['ReferencedField', resource.tableAlias, bindVar[0]]
			})
			query.from.push([
				[	'SelectQuery',
					[	'Select',
						_.map($elf.clientModel.resources[resource.resourceName].fields, function(field) {
							var cast,
								alias = field.fieldName,
								bindVar = _.find(bindVars, { 0: alias });
							if(bindVar) {
								cast = ['Cast', bindVar[1], field.dataType];
							}
							else {
								cast = 'Null';
							}
							return [cast, alias];
						})
					]
				],
				resource.tableAlias
			])
			query.where.push(where)
		}
		-> query
	,

	UpdateFilter :filter :resource :referencedIdField =
		// For update statements we need to use a WHERE id IN (SELECT...) style query
		{new Query()}:query
		AddExtraFroms(filter, query, resource)
		Boolean(filter):where
		{
			query.select.push(referencedIdField)
			query.fromResource(resource)
			query.where.push(where)
		}
		-> query
	,

	OrderBy :orderby :query :resource =
		AddExtraFroms(orderby.properties, query, resource)
		OrderByProperties(orderby.properties):orderby
		-> query.extras.push(['OrderBy'].concat(orderby))
	,

	OrderByProperties =
		[	(	:ordering
				ReferencedProperty(ordering):field
				-> [ordering.order.toUpperCase(), field]
			)+:orderby
		]
		-> orderby
	,

	BindVars :method :body :resourceName =
		[	(	[	'_name'
					anything
				]
				-> null
			|	[	:fieldName
					[	:mappedTableName
						:mappedFieldName
					]
				]
				(	?(!body || (!body.hasOwnProperty(fieldName) && !body.hasOwnProperty(resourceName + "." + fieldName)))
					// The body doesn't contain a bind var for this field.
					(	?(method === 'PUT')
						-> [mappedFieldName, 'Default']
					|	-> null
					)
				|	-> [mappedFieldName, ['Bind', resourceName, fieldName]]
				)
			)*:fields
		]
		-> _.compact(fields)
	,

	ResolveResourceAlias :aliasName =
		?this.resourceAliases[aliasName]
		-> this.resourceAliases[aliasName]
	,

	Resource :resourceName :parentResource =
			ResolveResourceAlias(resourceName)
		|	{this.clientModel.resources[resourceName]}:resource
			?resource
			{_.clone(resource)}:resource
			(	?resource.tableName
			|	ResourceMapping(resource):resourceMapping
				{resource.tableName = resourceMapping._name}
			)

			(	?parentResource
				-> (parentResource.tableAlias + '.' + resource.tableName)
			|	-> resource.tableName
			):tableAlias
			{resource.tableAlias = tableAlias}
			-> resource
		|	{throw new Error('Unknown resource: ' + resourceName)}
	,

	FieldContainedIn :fieldName :resource =
		ResourceMapping(resource):mapping
		{mapping[fieldName]}:mappedField
		?mappedField
		?(mappedField[0] == resource.tableAlias)
		?_.some(resource.fields, {fieldName: mappedField[1]})
	,

	ResourceMapping :resource =
			?this.clientModel.resourceToSQLMappings[resource.resourceName]
			{this.clientModel.resourceToSQLMappings[resource.resourceName]}:resourceMapping
			(	?resource.tableAlias
				?(resource.tableAlias != resourceMapping._name)
				{_.mapValues(resourceMapping, function(mapping) {
					if(_.isArray(mapping)) {
						return [resource.tableAlias, mapping[1]];
					}
					else {
 						return resource.tableAlias;
					}
				})}:resourceMapping
			)?
			-> resourceMapping
		|	{throw new Error('Unknown resource: ' + resource.resourceName)}
	,

        AddCountField :path :query :resource =
                      ?path.count
                      ( ?path.options
                        ?path.options.$select
                        AddExtraFroms(path.options.$select.properties, query, resource)
                      )?
                      -> (query.select.push(['Count', '*']))
        ,

	AddSelectFields :path :query :resource =
		(	?path.options
			?path.options.$select
			AddExtraFroms(path.options.$select.properties, query, resource)
			Properties(path.options.$select.properties):fields
			-> _(fields).reject(function(field) {
					return _.some(query.select, function(existingField) {
						return _.last(existingField) == field.name;
					});
				})
				.map(function(field) {
					return $elf.AliasSelectField(field.resource, field.name);
				})
				.value()
		|	ResourceMapping(resource):resourceMapping
			-> _(resourceMapping).keys().reject(function(fieldName) {
				return fieldName === '_name' || _.some(query.select, function(existingField) {
					return _.last(existingField) == fieldName;
				});
			}).map(_.bind(this.AliasSelectField, this, resource)).value()
		):fields
		-> (query.select = query.select.concat(fields))
	,

	AliasSelectField :resource :fieldName =
		ReferencedField(resource, fieldName):referencedField
		(	?(referencedField[2] === fieldName)
			-> referencedField
		|	-> [referencedField, fieldName]
		)
	,

	ReferencedField :resource :resourceField =
		ResourceMapping(resource):mapping
		(	?mapping[resourceField]
			-> ['ReferencedField'].concat(mapping[resourceField])
		|	{console.error('Unknown mapping: ', mapping, resourceTable, resourceField)}
			{throw new Error('Unknown mapping: ' + resourceTable + ' : ' + resourceField)}
		)
	,

	Boolean =
			True
		|	False
		|	[	(	(	'eq'
						-> 'Equals'
					|	'ne'
						-> 'NotEquals'
					|	'gt'
						-> 'GreaterThan'
					|	'ge'
						-> 'GreaterThanOrEqual'
					|	'lt'
						-> 'LessThan'
					|	'le'
						-> 'LessThanOrEqual'
					):operation
					Operand:op1
					Operand:op2
					-> [operation, op1, op2]
				|	(	'and'
						-> 'And'
					|	'or'
						-> 'Or'
					):operation
					Boolean:op1
					Boolean+:op2
					-> [operation, op1].concat(op2)
				):bool
			]
			-> bool
		|	[	'not'
				Boolean:bool
			]
			-> ['Not', bool]
		|	ReferencedProperty
		|	BooleanFunction
	,

	True =
		true
		-> ['Boolean', true]
	,

	False =
		false
		-> ['Boolean', false]
	,

	BooleanFunction =
			Function('contains')
		|	Function('endswith')
		|	Function('startswith')
		|	Function('isof')
		|	Function('substringof')
	,

	NumberFunction =
			AliasedFunction('length', 'CharacterLength')
		|	Function('indexof')
		|	Function('year')
		|	Function('month')
		|	Function('day')
		|	Function('day')
		|	Function('hour')
		|	Function('minute')
		|	Function('second')
		|	Function('fractionalseconds')
		|	Function('totaloffsetminutes')
		|	Function('totalseconds')
		|	Function('round')
		|	Function('floor')
		|	Function('ceiling')
	,

	TextFunction =
			Function('substring'):fn
			// First parameter needs to be increased by 1.
			{fn[2][1]++}
			-> fn
		|	Function('tolower')
		|	Function('toupper')
		|	Function('trim')
		|	Function('concat')
		|	AliasedFunction('date', 'ToDate')
		|	AliasedFunction('time', 'ToTime')
		|	Function('replace')
	,

	DateFunction =
			Function('now')
		|	Function('maxdatetime')
		|	Function('mindatetime')
	,

	AliasedFunction :odataName :sqlName =
		Function(odataName):fn
		-> [sqlName].concat(fn.slice(1))
	,

	Function :name =
		[	'call'
			:properties
			?(properties.method == name)
			Arguments(properties.args):args
		]
		-> [_.capitalize(name)].concat(args)
	,

	Arguments =
		[	Operand*:args
		]
		-> args
	,

	Operand =
			Null
		|	Boolean
		|	Number
		|	Text
		|	Date
		|	Duration
		|	Math
	,

	Math =
		[	(	'add'
				-> 'Add'
			|	'sub'
				-> 'Subtract'
			|	'mul'
				-> 'Multiply'
			|	'div'
				-> 'Divide'
			):operation
			Operand:op1
			Operand:op2
		]
		-> [operation, op1, op2]
	,

	Lambda :resource :lambda =
		{this.resourceAliases}:resourceAliases
		{this.defaultResource}:defaultResource
		{	this.resourceAliases = _.clone(this.resourceAliases);
			this.resourceAliases[lambda.identifier] = resource;
		}
		(	{new Query()}:query
			AddNavigation(query, this.defaultResource, resource)
			{this.defaultResource = resource}
			AddExtraFroms(lambda.expression, query, resource)
			Boolean(lambda.expression):filter
			{query.where.push(filter)}
			{query.compile('SelectQuery')}:query
			(	?(lambda.method == 'any')
				-> ['Exists', query]
			|	?(lambda.method == 'all')
				-> ['Not',
					['Exists',
						// Where not..
						_.map(query, function(queryPart) {
							if(queryPart[0] == 'Where') {
								return [queryPart[0], ['Not', queryPart[1]]];
							}
							return queryPart;
						})
					]
				]
			):result
			// Make sure resourceAliases/defaultResource are always reset at the end.
			{this.resourceAliases = resourceAliases}
			{this.defaultResource = defaultResource}
		|	{this.resourceAliases = resourceAliases}
			{this.defaultResource = defaultResource}
			?false
		)
		-> result
	,

	Properties =
		[	Property*:props
		]
		-> props
	,

	ReferencedProperty =
		Property:prop
		(	?_.isArray(prop)
			// It's the result of a lambda
			-> prop
		|	ReferencedField(prop.resource, prop.name)
		)
	,

	Property =
		:prop
		?prop.name
		(	?prop.property
			{this.defaultResource}:defaultResource
			(	{	try {
						return $elf.Resource(prop.name, this.defaultResource);
					} catch (e) {}
				}:propResource
				?propResource
				{this.defaultResource = propResource}
				Property(prop.property):result
				{this.defaultResource = defaultResource}
				-> result
			|	{this.defaultResource = defaultResource}
				Property(prop.property)
			)
		|	?(!prop.property)
			?prop.lambda
			Resource(prop.name, this.defaultResource):resource
			Lambda(resource, prop.lambda)
		|	?(!prop.property)
			?(!prop.lambda)
			-> {resource: this.defaultResource, name: prop.name}
		)
	,

	Number =
			number:num
			-> ['Number', num]
		|	NumberFunction
	,

	Null =
		anything:x
		?(x === null)
		-> 'Null'
	,

	Text =
			string:text
			-> ['Text', text]
		|	TextFunction
	,

	Date =
			anything:date
			?_.isDate(date)
			-> ['Date', date]
		|	DateFunction
	,

	Duration =
		anything:duration
		?_.isObject(duration)
		{	_(duration)
			.pick('negative', 'day', 'hour', 'minute', 'second')
			.omitBy(_.isNil)
			.value()
		}:duration
		?(!_(duration).omit('negative').isEmpty())
		-> ['Duration', duration]
	,

	Expands :resource :query =
		{this.defaultResource}:defaultResource
		[	(	:expand
				Resource(expand.name, defaultResource):expandResource
				{this.defaultResource = expandResource}
				// We need to nest the expand query in order to be able to alias column names to match the OData version.
				{new Query()}:nestedExpandQuery
				(	?(!expand.property)
				|	Expands(expandResource, nestedExpandQuery, [expand.property])
				)
				(	?(!expand.options)
				|	(	?(!expand.options.$expand)
					|	Expands(expandResource, nestedExpandQuery, expand.options.$expand.properties)
					)
				)
				{nestedExpandQuery.fromResource(expandResource)}

				AddSelectFields(expand, nestedExpandQuery, expandResource)
				(	?(!expand.options)
				|	(	?(!expand.options.$filter)
					|	SelectFilter(expand.options.$filter, nestedExpandQuery, expandResource)
					)
					(	?(!expand.options.$orderby)
					|	OrderBy(expand.options.$orderby, nestedExpandQuery, expandResource)
					)
					(	?(!expand.options.$top)
					|	Number(expand.options.$top):limit
						-> nestedExpandQuery.extras.push(['Limit', limit])
					)
					(	?(!expand.options.$skip)
					|	Number(expand.options.$skip):offset
						-> nestedExpandQuery.extras.push(['Offset', offset])
					)
				)
				{this.defaultResource = defaultResource}

				NavigateResources(resource, expandResource):navigationWhere
				{nestedExpandQuery.where.push(navigationWhere)}

				{new Query()}:expandQuery
				{expandQuery.select.push([['AggregateJSON', [expandResource.tableAlias, '*']], expandResource.resourceName])}
				{expandQuery.from.push([nestedExpandQuery.compile('SelectQuery'), expandResource.tableAlias])}
				{query.select.push([expandQuery.compile('SelectQuery'), expandResource.resourceName])}
			)+
		]
	,

	NavigateResources :resource1 :resource2 =
		(	FieldContainedIn(resource1.resourceName, resource2)
			ReferencedField(resource2, resource1.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource1.tableAlias, resource1.idField],
				fkField
			]
		|	FieldContainedIn(resource2.resourceName, resource1)
			ReferencedField(resource1, resource2.resourceName):fkField
			-> ['Equals',
				['ReferencedField', resource2.tableAlias, resource2.idField],
				fkField
			]
		|	{throw new Error('Cannot navigate resources ' + resource1.tableName + ' and ' + resource2.tableName)}
		)
	,

	AddExtraFroms :searchPoint :query :resource =
		ExtraFroms(searchPoint):extraFroms
		{	_.each(extraFroms, function(extraResource) {
				var currentResource = resource;
				if(_.isArray(extraResource)) {
					_.each(extraResource, function(extraResource) {
						$elf.AddNavigation(query, currentResource, extraResource);
						currentResource = extraResource;
					});
				}
				else {
					$elf.AddNavigation(query, currentResource, extraResource);
				}
			});
		}
	,

	// Returns the resource names.
	ExtraFroms =
		{[]}:froms
		(	?(_.isArray(this.input.hd))
			[	(	ExtraFroms:extraFroms
					{froms.concat(extraFroms)}:froms
				)*
			]
		|	:nextProp
			{this.defaultResource}:parentResource
			(	{nextProp}:prop
				?prop
				?prop.name
				?prop.property
				?prop.property.name
				{prop.property}:nextProp
				Resource(prop.name, parentResource):parentResource
			)+:extraFroms
			(	?(extraFroms.length == 1)
				-> froms.push(extraFroms[0])
			|	-> froms.push(extraFroms)
			)
		| anything
		)
		-> froms
	,

	AddNavigation :query :resource :extraResource =
		(	?(!_.some(query.from, function(from) {
				return from === extraResource.tableAlias ||
					(_.isArray(from) && from[1] === extraResource.tableAlias);
			}))
			NavigateResources(resource, extraResource):nagivationWhere
			{query.fromResource(extraResource)}
			{query.where.push(nagivationWhere)}
		)?
}

OData2AbstractSQL.initialize = function() {
	this.reset();
};

OData2AbstractSQL.reset = function() {
	this.resourceAliases = {};
	this.defaultResource = null;
};
